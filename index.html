<!doctype html>
<html lang="de">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="color-scheme" content="dark light" />
    <title>Teilchenbeschleuniger – Prototyp</title>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet"/>

    <style>
      /* ================= TOKENS / RESET ================= */
      *, *::before, *::after { box-sizing: border-box; }
      :root {
        --bg:#0b0b0c; --fg:#fafafa; --muted:#a8a8ab; --card:#141416; --line:#242428;
        --accent:#7dd3fc; --marker:#f59e0b; --disabled:#3a3a3f;
      }
      html,body { margin:0; height:100%; scroll-behavior:smooth; }
      body { font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif; background:var(--bg); color:var(--fg); }
      img { max-width:100%; display:block; }
      a { color:inherit; }

      .container { max-width:1100px; margin:0 auto; padding:0 20px; }
      .header { position:sticky; top:0; z-index:40; backdrop-filter:saturate(120%) blur(10px); background:rgba(11,11,12,.6); border-bottom:1px solid var(--line); }
      .nav { display:flex; align-items:center; justify-content:space-between; padding:14px 20px; }
      .nav a { color:var(--muted); text-decoration:none; font-size:14px; margin-left:18px; }
      .nav a:hover { color:var(--fg); }

      .section { padding:80px 0; border-top:1px solid var(--line); scroll-margin-top:84px; }
      .reveal{opacity:0;transform:translateY(16px);transition:opacity .5s ease,transform .6s ease}
      .reveal.show{opacity:1;transform:none}

      /* ================= HERO ================= */
      .hero{position:relative;min-height:88vh;display:grid;place-items:center;overflow:hidden}
      .hero .bg{position:absolute;inset:0;background:radial-gradient(1200px 600px at 70% 20%,rgba(255,255,255,.08),transparent),linear-gradient(180deg,#0c0c10,#09090b)}
      .hero .content{position:relative;text-align:center;padding:40px}
      .title{font-size:clamp(36px,6vw,72px);font-weight:700;letter-spacing:-.02em}
      .subtitle{max-width:750px;margin:14px auto 0;color:var(--muted);font-size:clamp(16px,2.2vw,18px)}

      .grid{display:grid;gap:22px}
      .card{background:var(--card);border:1px solid var(--line);border-radius:18px;padding:18px}

      /* ================= HORIZONTAL TIMELINE ================= */
      #timeline h2 { font-size: clamp(26px, 3.8vw, 40px); margin:0 0 16px; }
      .timeline-slider { display:flex; align-items:center; justify-content:center; gap:18px; margin:40px 0; }
      .event-card { position:relative; display:flex; gap:22px; background:var(--card); border:1px solid var(--line); border-radius:18px; padding:22px; max-width:920px; width:100%; overflow:hidden; }
      .event-media { flex:0 0 360px; }
      .event-media img { width:100%; height:260px; border-radius:12px; object-fit:cover; }
      .event-info { flex:1; display:flex; flex-direction:column; gap:8px; }
      .event-info .date { color:var(--muted); font-size:14px; }
      .event-info h3 { margin:0; font-size:clamp(18px,2vw,28px); font-weight:700; letter-spacing:-.01em; }
      .event-info p { font-size:15px; color:var(--muted); margin:0; }
      .event-info a { width:fit-content; margin-top:8px; color:var(--accent); text-decoration:none; font-weight:600; }

      .nav-btn { background:transparent; border:2px solid var(--line); border-radius:50%; width:44px; height:44px; color:var(--fg); cursor:pointer; display:grid; place-items:center; transition:transform .25s ease, background .25s ease, opacity .25s ease; }
      .nav-btn:hover { background:var(--line); transform:scale(1.05); }
      .nav-btn:active { transform:scale(.97); }
      .nav-btn[disabled] { cursor:not-allowed; opacity:.4; background:transparent !important; transform:none !important; }

      .progress { margin-top:22px; position:relative; }
      .bar { height:4px; background:#2d2d32; border-radius:999px; position:relative; overflow:visible; }
      .marker { position:absolute; top:50%; left:0; width:16px; height:16px; background:var(--marker); border-radius:50%; box-shadow:0 0 0 4px rgba(255,255,255,.08); transform:translate(-8px,-50%); transition:transform .55s cubic-bezier(.22,.61,.36,1); }

      .pips { position:absolute; inset:0; pointer-events:none; }
      .pip { position:absolute; top:50%; width:12px; height:12px; border-radius:50%; background:var(--disabled); transform:translate(-6px,-50%); border:2px solid var(--bg); box-shadow:0 0 0 3px rgba(255,255,255,.06); pointer-events:auto; cursor:pointer; transition:background .2s ease, transform .2s ease; }
      .pip:hover { transform:translate(-6px,-50%) scale(1.07); }
      .pip.active { background:var(--marker); box-shadow:0 0 0 4px rgba(245,158,11,.15); }

      .labels { display:flex; justify-content:space-between; gap:8px; margin-top:8px; font-size:12px; color:var(--muted); white-space:nowrap; }

      .event-card .anim-wrap{ position:relative; flex:1; display:flex; gap:22px; }
      .slide { display:flex; gap:22px; width:100%; }
      .slide.enter { animation: fadeIn .45s cubic-bezier(.22,.61,.36,1); }
      .slide.leave { animation: fadeOut .38s cubic-bezier(.4,.0,.2,1); position:absolute; inset:0; }
      @keyframes fadeIn { from{opacity:0; transform:translateY(8px)} to{opacity:1; transform:none} }
      @keyframes fadeOut { from{opacity:1; transform:none} to{opacity:0; transform:translateY(-8px)} }

      @media (max-width: 900px){
        .event-card{ flex-direction:column; }
        .event-media{ flex-basis:auto; }
        .event-media img{ height:220px; }
      }

      /* ================= TOPIC GRID ================= */
      .topic-grid{ display:grid; gap:6px; margin:18px 0; grid-template-columns: 1fr; perspective:800px; }
      .topic-card{ position:relative; background:var(--card); border:1px solid var(--line); border-radius:16px; padding:16px; min-height:60px; text-decoration:none; color:var(--fg); display:flex; flex-direction:column; justify-content:center; gap:6px; transition:transform .25s ease, box-shadow .25s ease, border-color .25s ease, background .25s ease; will-change:transform; }
      .topic-card h3{ margin:0; font-size:16px; letter-spacing:-.01em; }
      .topic-card p{ margin:0; font-size:13px; color:var(--muted); }
      .topic-card:hover, .topic-card:focus-visible{ transform: translateY(-2px) scale(1.01) rotateX(1deg); border-color: var(--accent); box-shadow: 0 6px 20px rgba(125,211,252,.18); outline:none; background: linear-gradient(180deg,#18181b,#141416); }
      @media (max-width:900px){ .topic-grid{ grid-template-columns: 1fr 1fr; } }
      @media (max-width:600px){ .topic-grid{ grid-template-columns: 1fr; } }

      /* ================= ACCORDION ================= */
      .accordion{padding:0; overflow:hidden; border:1px solid var(--line); border-radius:16px; transition:border-color .28s ease, box-shadow .28s ease, background .28s ease}
      .accordion-header{
        width:100%; display:flex; justify-content:space-between; align-items:center;
        gap:12px; padding:16px 18px; background:transparent; border:0; color:var(--fg);
        cursor:pointer; font-size:24px; font-weight:700; text-align:left;
      }
      .accordion .chev{transition:transform .3s ease, color .3s ease; opacity:.9}
      .accordion.open .chev{transform:rotate(90deg); color:#9affa7}
      .accordion-content{ height:0; overflow:hidden; padding:0 18px; transition: height .42s cubic-bezier(.22,.61,.36,1); will-change: height; color:var(--muted); }
      .accordion-inner{ padding:12px 0 16px; }
      .accordion.open{ border-color:#90ff86; box-shadow:0 6px 22px rgba(134,225,255,.16); }
      @media (max-width:900px){ .accordion-header{font-size:16px; padding:14px 16px} }

      /* ================= Beschleuniger kette ================= */
      #chain-switch .sub{ color:var(--muted); margin:-6px 0 16px; }
      .chain-toggle{ display:grid; grid-template-columns:1fr 1fr; gap:12px; margin:8px 0 20px; }
      .mode-btn{ width:100%; padding:16px; font-weight:600; border-radius:9999px; border:1px solid var(--line); background:var(--card); color:var(--fg); cursor:pointer; transition: background .25s ease, box-shadow .25s ease, border-color .25s ease, transform .15s ease; }
      .mode-btn:hover{ transform:translateY(-2px); border-color:var(--accent); box-shadow:0 8px 20px rgba(134,225,255,.15); }
      .mode-btn.active{ background:linear-gradient(180deg,#181a1f,#13151a); border-color:var(--accent); box-shadow:0 8px 22px rgba(134,225,255,.22); }
      @media(max-width:700px){ .chain-toggle{ grid-template-columns:1fr; } }

      .flow-card { display:grid; grid-template-columns: 1fr 1fr; gap:24px; background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.015)); border:1px solid var(--line); border-radius:18px; padding:60px 20px 20px; box-shadow:0 10px 30px rgba(0,0,0,.25); position:relative; }
      .flow-step-title { position:absolute; top:16px; left:50%; transform:translateX(-50%); font-size:22px; font-weight:800; margin:0; text-align:center; width:calc(100% - 40px); }
      .flow-right { display:flex; flex-direction:column; align-items:center; text-align:center; }
      .flow-left { position:relative; display:flex; flex-direction:column; justify-content:flex-start; height:100%; max-height:490px; overflow-y:auto; padding-bottom:50px; }
      .flow-mini-text { margin:0 0 12px; font-size:15px; line-height:1.6; color:var(--muted); }
      .step-nav-fixed { position:absolute; bottom:0; left:50%; transform:translateX(-50%); display:flex; gap:12px; }

      .step-btn { padding:10px 32px; min-width:160px; border-radius:12px; border:1px solid var(--line); background:#121215; color:var(--fg); font-weight:300; font-size:12px; text-align:center; cursor:pointer; transition: background .25s ease, border-color .25s ease, transform .12s ease, opacity .25s ease; }
      .step-btn:hover { background:#1b1b20; border-color:var(--accent); }
      .step-btn:disabled { opacity:.5; cursor:not-allowed; }
      @media (max-width:900px){ .flow-card{ grid-template-columns:1fr } .flow-left{ max-height:none; padding-bottom:60px; } }

      .mv-dot{
        opacity: 0 !important;
        background: transparent !important;
        border: none !important;
        box-shadow: none !important;
        pointer-events: none !important;
      }
      .mv-dot:focus,
      .mv-dot:focus-visible{ outline: none !important; }

      /* ================= HOTSPOTS (Bild) ================= */
      #ring-hotspots .stage{position:relative;border-radius:18px;overflow:hidden;border:1px solid var(--line);background:#0f0f12}
      #ring-hotspots .stage img{width:100%;height:520px;object-fit:cover;opacity:.85;filter:grayscale(20%)}
      .hotspot{position:absolute;width:18px;height:18px;border-radius:50%;background:#fff;box-shadow:0 0 0 6px rgba(255,255,255,.15);cursor:pointer;border:none;padding:0}
      .hotspot:focus{outline:2px solid #fff}
      .fact{position:absolute;min-width:240px;max-width:320px;background:var(--card);border:1px solid var(--line);border-radius:16px;padding:14px;line-height:1.4;display:none}
      .fact h3{margin:0 0 6px;font-size:16px}
      .fact p{margin:0;color:var(--muted);font-size:14px}
      .fact.show{display:block}

      /* ================= PHYSIK DEMO ================= */
      #acceleration-chain .chain{display:grid;grid-template-columns:1fr 1fr;gap:22px}
      .timeline-box{position:relative;background:var(--card);border:1px solid var(--line);border-radius:18px;padding:18px}
      .timeline-box ul{list-style:none;padding:0;margin:0}
      .timeline-box li{display:flex;align-items:center;gap:12px;padding:12px 6px;border-radius:12px;cursor:pointer}
      .timeline-box .dot{width:10px;height:10px;border-radius:50%;background:#888}
      .timeline-box li.active .dot{background:#fff}
      .timeline-box li .label{font-weight:600}
      .metrics{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
      .metric{background:var(--card);border:1px solid var(--line);border-radius:16px;padding:16px;text-align:center}
      .metric .v{font-size:24px;font-weight:700}
      #bfield{appearance:none;width:100%}
      #bfield::-webkit-slider-thumb{appearance:none;width:18px;height:18px;border-radius:50%;background:#fff}
      #bfield::-webkit-slider-runnable-track{height:4px;background:#2d2b30;border-radius:999px}
      .svgbox{background:var(--card);border:1px solid var(--line);border-radius:18px;padding:14px}
      @media (max-width:900px){ #acceleration-chain .chain{grid-template-columns:1fr} }

      /* ================= RINGS ================= */
      #collision-detector .rings{display:grid;grid-template-columns:1fr 1fr;gap:22px}
      .detector{position:relative;aspect-ratio:1/1;border-radius:18px;border:1px solid var(--line);overflow:hidden;background:radial-gradient(circle at 50% 50%,#1b1b1f,#101014)}
      .layer{position:absolute;border-radius:50%;border:3px solid rgba(255,255,255,.28);opacity:.2;transition:opacity .35s, transform .35s}
      .layer.show{opacity:.95;transform:scale(1.02)}
      .layers-legend .row{display:flex;align-items:center;justify-content:space-between;background:var(--card);border:1px solid var(--line);border-radius:14px;padding:10px 12px;margin-bottom:10px}
      .layers-legend .row .name{font-weight:600}
      .layers-legend button{border:none;background:#fff;color:#000;padding:6px 10px;border-radius:10px;cursor:pointer;font-weight:600}
      @media (max-width:900px){ #collision-detector .rings{grid-template-columns:1fr} }

      /* ================= SAFETY / FOOTER ================= */
      .safety{display:grid;grid-template-columns:repeat(3,1fr);gap:14px}
      @media (max-width:900px){ .safety{grid-template-columns:1fr} }
      .footer{padding:40px 0;color:var(--muted);text-align:center;border-top:1px solid var(--line)}

      /* ================= Anchor Flash ================= */
      .section.flash{position:relative}
      .section.flash::before{
        content:""; position:absolute; inset:-2px; border-radius:20px; border:2px solid var(--accent);
        box-shadow:0 0 24px rgba(125,211,252,.35), 0 0 0 9999px rgba(0,0,0,0); pointer-events:none; opacity:0;
        animation: flashPulse 1200ms ease-out forwards 300ms;
      }
      @keyframes flashPulse{ 0%{opacity:0} 20%{opacity:1} 60%{opacity:.85} 100%{opacity:0} }

      .flow-viewport { width: 100%; aspect-ratio: 1 / 1; border-radius: 14px; border: 1px solid var(--line); overflow: hidden; background: #0f1014; }
      model-viewer { width: 100%; height: 100%; display: block; outline: none; }

      /* === PONG OVERLAY ===================================== */
      #pong-overlay[hidden]{ display:none !important; }
      #pong-overlay{
        position:fixed; inset:0; z-index:9999;
        background:rgba(5,6,8,.92);
        display:grid; grid-template-rows:1fr auto; gap:0;
        backdrop-filter:saturate(115%) blur(6px);
      }
      #pong-stage{ position:relative; display:grid; place-items:center; padding:16px; }
      #pong-canvas{
        width: min(100vw, 1000px);
        height: min(calc(100vh - 120px), 700px);
        border: 1px solid var(--line);
        border-radius: 16px;
        background: radial-gradient(circle at 50% 50%, #0f1116, #0b0c10 60%);
        box-shadow: inset 0 20px 60px rgba(0,0,0,.45);
      }
      #pong-hud{
        display:flex; align-items:center; justify-content:space-between;
        gap:12px; padding:10px 16px; border-top:1px solid var(--line);
        background:linear-gradient(180deg,#131418,#0e0f13);
      }
      .pong-pill{ display:inline-flex; align-items:center; gap:10px; border:1px solid var(--line); border-radius:9999px; padding:8px 12px; background:var(--card); color:var(--fg); font-weight:600; font-size:13px; }
      .pong-muted{ color:var(--muted); font-weight:500; }
      #pong-close{ border:1px solid var(--line); background:transparent; color:var(--fg); border-radius:10px; padding:8px 12px; cursor:pointer; }
      #pong-close:hover{ background:#17181c; border-color:var(--accent); }

      /* Blaue MV-Hotspots (ohne Labels) */
      .mv-dot{
        --size: 14px;
        width: var(--size);
        height: var(--size);
        border-radius: 50%;
        border: 2px solid #0ea5ff;
        background: #38bdf8;
        box-shadow: 0 0 0 6px rgba(56,189,248,.18);
        cursor: pointer;
      }
      .mv-dot:focus{ outline: 2px solid #fff; outline-offset: 2px; }
      
      #dvd-wrap {
        position: fixed;
        inset: 0;
        z-index: 9999;
        background: transparent;    
        opacity: 0;             
        pointer-events: none;       
        transition: opacity 2s ease;
      }
      

      #dvd-wrap.active {
        opacity: 1;
        pointer-events: auto;       
      }

      
      #content-wrap.blur {
        filter: blur(12px);      
        transition: filter 2s cubic-bezier(.4, 0, .2, 1);
      }
      
      #dvd-box iframe,
      #dvd-box video {
        width: 2000px;   
        height: auto;  
        max-width: 200vw; 
      }
    
      #content-wrap {
        transition: filter 2s cubic-bezier(.4, 0, .2, 1);
      }

      
      .clip-card {
        background: var(--card, #141416);
        border: 1px solid var(--line, #242428);
        border-radius: 18px;
        padding: 18px;
        max-width: 1000px;
        margin: 40px auto;
      }
      
      .clip-box {
        display: grid;
        grid-template-columns: 1.1fr 1.4fr;
        gap: 24px;
        align-items: stretch;
      }
      @media (max-width:900px){ .clip-box { grid-template-columns: 1fr; } }
      
      .clip-left { display:flex; flex-direction:column; gap:14px; }
      .clip-controls { margin-top:auto; display:flex; gap:12px; }
      
      .step-btn {
        padding:10px 32px;
        min-width:160px;
        border-radius:12px;
        border:1px solid var(--line, #242428);
        background:#121215;
        color:var(--fg, #fafafa);
        font-weight:300;
        font-size:12px;
        cursor:pointer;
      }
      .step-btn:hover { background:#1b1b20; border-color:var(--accent, #7dd3fc); }
      .step-btn:disabled { opacity:.5; cursor:not-allowed; }
      
      .clip-right {
        position:relative;
        border:1px solid var(--line, #242428);
        border-radius:16px;
        overflow:hidden;
        background:#000;
        aspect-ratio:1/1;   /* square player */
        width:100%;
      }

      #vfader {
        position:absolute;
        inset:0;
        pointer-events:none;
        opacity:0;
        background:rgba(0,0,0,.35);
      }
      #vfader.fade {
        transition:opacity .35s ease;
        opacity:1;
      }


      </style>
      <style>
        .clip-card {
          background: #141416;
          border: 1px solid #242428;
          border-radius: 18px;
          padding: 18px;
          max-width: 1000px;
          margin: 40px auto;
        }
      
        .clip-box {
          display: grid;
          grid-template-columns: 1.1fr 1.4fr;
          gap: 24px;
          align-items: stretch;
        }
        @media (max-width:900px){ .clip-box { grid-template-columns: 1fr; } }
      
        .clip-left { display:flex; flex-direction:column; gap:14px; }
        .clip-controls { margin-top:auto; display:flex; gap:12px; }
      
        .step-btn {
          padding:10px 32px;
          min-width:160px;
          border-radius:12px;
          border:1px solid #242428;
          background:#121215;
          color:#fafafa;
          font-weight:300;
          font-size:12px;
          cursor:pointer;
          transition: background .25s ease, border-color .25s ease, opacity .25s ease;
        }
        .step-btn:hover { background:#1b1b20; border-color:#7dd3fc; }
        .step-btn:disabled { opacity:.5; cursor:not-allowed; }
      
        .clip-right {
          position:relative;
          border:1px solid #242428;
          border-radius:16px;
          overflow:hidden;
          background:#000;
          aspect-ratio:1/1;
          width:100%;
        }
      
        .clip-right video {
          position:absolute;
          inset:0;
          width:100%;
          height:100%;
          object-fit:contain;
          background:#000;
          opacity:0;
          transition: opacity .22s ease; /* kurzer, knackiger Crossfade */
        }
        .clip-right video.active { opacity:1; }
      
        /* sanfter Overlay-Fader für harte Sprünge (meist unsichtbar dank Preload) */
        #vfader {
          position:absolute; inset:0; pointer-events:none;
          background:rgba(0,0,0,.35);
          opacity:0; transition:opacity .18s ease;
        }
        #vfader.fade { opacity:1; }
      </style>
    </head>
  <body>
    <!-- ================= HEADER ================= -->
    <header class="header">
      <div class="nav container">
        <div>Beschleuniger</div>
        <nav aria-label="Hauptnavigation">
          <a href="#cern-teile">Einleitung</a>
          <a href="#timeline">Timeline</a>
          <a href="#chain-switch">Beschleunigerkette</a>
          <a href="#ring-hotspots">Teilchenbeschleuniger</a>
          <a href="#acceleration-chain">Detektoren</a>
          <a href="#collision-detector">Kollision</a>
          <a href="#sources">Quellen</a>
        </nav>
      </div>
    </header>

      
    <div id="content-wrap">  
      <!-- ================= HERO ================= -->
      <section class="hero" id="hero" aria-labelledby="hero-title">
        <div class="bg" aria-hidden="true"></div>
        <div class="content container">
          <h1 class="title" id="hero-title">Teilchen auf nahezu Lichtgeschwindigkeit</h1>
          <p class="subtitle">Eine Einführung in CERN, seine Geschichte und seine Beschleuniger (Fokus: LHC-Komplex) – plus ein Blick auf die Physik dahinter.</p>
        </div>
      </section>
  
      <!-- ================= EINLEITUNG ================= -->
      <section class="section" id="cern-teile">
        <div class="container">
          <div class="accordion card reveal" id="cern-accordion">
            <button class="accordion-header" type="button" aria-expanded="false" aria-controls="cern-accordion-content">
              <span>Was ist CERN?</span>
              <span class="chev" aria-hidden="true">▸</span>
            </button>
            <div class="accordion-content" id="cern-accordion-content">
              <div class="accordion-inner">
                Das CERN (Europäische Organisation für Kernforschung) ist eines der größten Forschungszentren
                der Welt. Es liegt an der Grenze zwischen der Schweiz und Frankreich bei Genf. Am bekanntesten
                ist das CERN für den Large Hadron Collider (LHC), mit dem die kleinsten Bausteine des Universums erforscht werden.
              </div>
            </div>
          </div>
  
          <!-- Links -->
          <div class="topic-grid" aria-label="Themen">
            <a class="topic-card" href="#timeline">
              <h3>Zeitleiste</h3>
              <p>Wichtige Geschehnisse im Laufe der Zeit</p>
            </a>
            <a class="topic-card" href="#chain-switch">
              <h3>Beschleunigerkette</h3>
              <p>Stufen & Detektoren im LHC-Komplex</p>
            </a>
            <a class="topic-card" href="#ring-hotspots">
              <h3>Teilchenbeschleuniger</h3>
              <p>Funktionsweise und Arten am CERN</p>
            </a>
            <a class="topic-card" href="#acceleration-chain">
              <h3>Physik</h3>
              <p>Die Grundlagen hinter den Beschleunigern</p>
            </a>
            <a class="topic-card" href="#collision-detector">
              <h3>Kollisionen</h3>
              <p>Was in den Detektoren passiert</p>
            </a>
            <a class="topic-card" href="#sources">
              <h3>Quellen</h3>
              <p>Quellen & Arbeitsnachweise</p>
            </a>
          </div>
        </div>
      </section>
  
      <!-- ================= TIMELINE ================= -->
      <section class="section" id="timeline">
        <div class="container">
          <h2 class="reveal">Geschichte</h2>
  
          <div class="timeline-slider reveal">
            <button class="nav-btn prev" type="button" aria-label="Zurück" title="Zurück">◀</button>
  
            <div class="event-card" aria-live="polite">
              <div class="anim-wrap"><!-- dynamic slide injected here --></div>
            </div>
  
            <button class="nav-btn next" type="button" aria-label="Weiter" title="Weiter">▶</button>
          </div>
  
          <div class="progress" aria-label="Zeitstrahl">
            <div class="bar" id="tl-bar">
              <div class="marker" id="tl-marker" aria-hidden="true"></div>
              <div class="pips" id="tl-pips"></div>
            </div>
            <div class="labels" id="tl-labels"></div>
          </div>
        </div>
      </section>
  
      <!-- ================= BESCHLEUNIGERKETTE (Model Viewer) ================= -->
      <section class="section" id="chain-switch">
        <div class="container">
          <h2>Beschleunigerkette</h2>
          <p class="sub">Erkunde die Elemente der LHC Beschleunigerkette für Protonen</p>
  
  
          <div class="flow-card" aria-live="polite">
            <h3 class="flow-step-title" id="flow-title">Linear Accelerator 4 (LINAC4)</h3>
  
            <div class="flow-right">
              <div class="flow-viewport">
  
                <model-viewer
                  id="mv"
                  src="LHC.glb"
                  alt="LHC"
                  camera-controls
                  auto-rotate
                  touch-action="pan-y"
                  disable-pan
                  exposure="0.9"
                  shadow-intensity="3"
                  environment-image="neutral"
                  interaction-prompt="none"
  
                  field-of-view="45deg"
                
                  min-camera-orbit="auto 60deg 10m"
                  max-camera-orbit="auto 60deg 4000m"
                
                  interpolation-decay="200">
                
                  <!-- 9 Hotspots (ohne Labels) -->
                  <button class="mv-dot" slot="hotspot-LINAC4"    data-name="LINAC4"    data-position="20.6911m -0.684515m -112.797m"  data-normal="0m 1m 0m"></button>
                  <button class="mv-dot" slot="hotspot-PSBooster" data-name="PSBooster" data-position="36.691m 0.25m -77.884m"         data-normal="0m 1m 0m"></button>
                  <button class="mv-dot" slot="hotspot-PS"        data-name="PS"        data-position="-0.06m 0.25m -80.025m"          data-normal="0m 1m 0m"></button>
                  <button class="mv-dot" slot="hotspot-SPS"       data-name="SPS"       data-position="0m 0.25m 253.5m"                data-normal="0m 1m 0m"></button>
                  <button class="mv-dot" slot="hotspot-LHC"       data-name="LHC"       data-position="0m 0.25m 877.53m"               data-normal="0m 1m 0m"></button>
                  <button class="mv-dot" slot="hotspot-ATLAS"     data-name="ATLAS"     data-position="0m 0.25m -4.5m"                 data-normal="0m 1m 0m"></button>
                  <button class="mv-dot" slot="hotspot-ALICE"     data-name="ALICE"     data-position="473m 0.25m 144.7m"              data-normal="0m 1m 0m"></button>
                  <button class="mv-dot" slot="hotspot-LHCb"      data-name="LHCb"      data-position="-518.19m 0.25m 178.78m"         data-normal="0m 1m 0m"></button>
                  <button class="mv-dot" slot="hotspot-CMS"       data-name="CMS"       data-position="-16.125m 0.25m 1762m"           data-normal="0m 1m 0m"></button>
                
                </model-viewer>
                
                <!-- Smooth focus/zoom controller -->
                <script>
                (function(){
                  const mv = document.getElementById('mv');
                  if(!mv) return;
                
                  // Utils
                  const parsePos = (s) => (s||'0m 0m 0m').split(' ').map(p => parseFloat(String(p).replace('m',''))||0);
                  const fmtPos   = (v) => `${v[0].toFixed(3)}m ${v[1].toFixed(3)}m ${v[2].toFixed(3)}m`;
                  const parseOrbit = (s) => {
                    const parts = (s||'auto auto 200m').split(' ');
                    const num = (p)=> (p==null||p==='auto')?null:parseFloat(p);
                    return { theta: parts[0]==='auto'?null:num(parts[0]), phi: parts[1]==='auto'?null:num(parts[1]), r: num(parts[2])??200 };
                  };
                  const fmtOrbit = ({theta=null,phi=null,r=200}) => `${theta==null?'auto':theta+'deg'} ${phi==null?'auto':phi+'deg'} ${(+r).toFixed(3)}m`;
                  const easeInOutCubic=(t)=> t<0.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2;
                
                  function readPositions(){
                    const map={};
                    mv.querySelectorAll('button.mv-dot[data-name]').forEach(btn=>{
                      map[btn.dataset.name]=btn.dataset.position||'0m 0m 0m';
                    });
                    return map;
                  }
                  let POS = readPositions();
                  const mo = new MutationObserver(()=>{ POS = readPositions(); });
                  mo.observe(mv,{subtree:true, attributes:true, attributeFilter:['data-position']});
                
                  const ORBIT_RADIUS = {
                    LINAC4:   20,
                    PSBooster:25,
                    PS:      200,
                    SPS:     1000,
                    LHC:     4000,
                    ATLAS:   20,
                    CMS:     20,
                    ALICE:   20,
                    LHCb:    20
                  };
  
  
                
                  let currTarget=null;
                  let currOrbit=null;
                  let animId=null;
                
                  mv.addEventListener('load', ()=>{
                    const attrTarget = mv.getAttribute('camera-target');
                    currTarget = (attrTarget && !/auto/i.test(attrTarget)) ? parsePos(attrTarget)
                                : POS.LINAC4 ? parsePos(POS.LINAC4) : [0,0,0];
                    currOrbit = parseOrbit(mv.getAttribute('camera-orbit'));
                    if(!currOrbit || isNaN(currOrbit.r)) currOrbit = {theta:null, phi:null, r: ORBIT_RADIUS.LINAC4};
                    mv.setAttribute('camera-target', fmtPos(currTarget));
                    mv.setAttribute('camera-orbit',  fmtOrbit(currOrbit));
                  }, {once:true});
                
                  function stopAnim(){ if(animId){ cancelAnimationFrame(animId); animId=null; } }
                
                  async function focusTo(name, duration=900){
                    const targetStr = POS[name];
                    if(!targetStr) return;
                    if(mv.updateComplete) await mv.updateComplete;
                
                    const startPos   = currTarget || (mv.getAttribute('camera-target') ? parsePos(mv.getAttribute('camera-target')) : [0,0,0]);
                    const endPos     = parsePos(targetStr);
                    const startOrbit = currOrbit || parseOrbit(mv.getAttribute('camera-orbit'));
                    const desiredR   = ORBIT_RADIUS[name] ?? startOrbit.r ?? 200;
                    const endOrbit   = { theta:startOrbit.theta, phi:startOrbit.phi, r:desiredR };
                
                    const t0 = performance.now();
                    stopAnim();
                
                    const step = (now)=>{
                      const t = Math.min(1,(now - t0)/duration);
                      const k = easeInOutCubic(t);
                
                      const pos = [
                        startPos[0] + (endPos[0]-startPos[0]) * k,
                        startPos[1] + (endPos[1]-startPos[1]) * k,
                        startPos[2] + (endPos[2]-startPos[2]) * k,
                      ];
                      const r = (startOrbit.r ?? 200) + ((endOrbit.r)-(startOrbit.r ?? 200)) * k;
                
                      mv.setAttribute('camera-target', fmtPos(pos));
                      mv.setAttribute('camera-orbit',  fmtOrbit({theta:startOrbit.theta, phi:startOrbit.phi, r}));
                
                      if(t<1){
                        animId = requestAnimationFrame(step);
                      }else{
                        currTarget = endPos;
                        currOrbit  = {theta:startOrbit.theta, phi:startOrbit.phi, r:endOrbit.r};
                        animId = null;
                      }
                    };
                    animId = requestAnimationFrame(step);
                  }
                
                  mv.addEventListener('click', (e)=>{
                    const btn = e.composedPath().find(n=> n?.classList?.contains?.('mv-dot'));
                    if(btn && btn.dataset?.name){
                      focusTo(btn.dataset.name, 800);
                    }
                  });
                
                  window.__MV_FOCUS__ = { focusTo, get POS(){ return POS; } };
                })();
                </script>
                
                <!-- Control Panel (XY editor) -->
                <div id="mv-hotspot-controls" class="card" style="margin-top:12px">
                  <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:end">
                    <label>
                      <div style="font-size:12px;color:var(--muted)">Hotspot</div>
                      <select id="mv-hotspot-select">
                        <option>LINAC4</option>
                        <option>PSBooster</option>
                        <option>PS</option>
                        <option>SPS</option>
                        <option>LHC</option>
                        <option>ATLAS</option>
                        <option>CMS</option>
                        <option>ALICE</option>
                        <option>LHCb</option>
                      </select>
                    </label>
                    <label>
                      <div style="font-size:12px;color:var(--muted)">x (m)</div>
                      <input id="mv-x" type="number" step="0.1" value="0" style="width:110px">
                    </label>
                    <label>
                      <div style="font-size:12px;color:var(--muted)">y (m)</div>
                      <input id="mv-y" type="number" step="0.1" value="0" style="width:110px">
                    </label>
                    <button id="mv-apply" class="step-btn" type="button">Setzen</button>
                  </div>
                  <div style="margin-top:8px; font-size:12px; color:var(--muted)">
                    Hinweis: Z bleibt hier 0 m (kannst du im Script erweitern).
                  </div>
                </div>
                
                <script>
                (function(){
                  const mv = document.getElementById('mv');
                  const sel = document.getElementById('mv-hotspot-select');
                  const xIn = document.getElementById('mv-x');
                  const yIn = document.getElementById('mv-y');
                  const btn = document.getElementById('mv-apply');
                  const getBtn = (name)=> mv.querySelector(`button.mv-dot[data-name="${name}"]`);
                  function load(name){
                    const b=getBtn(name); if(!b) return;
                    const [xm,ym] = (b.dataset.position||'0m 0m 0m').split(' ');
                    xIn.value=parseFloat(xm)||0; yIn.value=parseFloat(ym)||0;
                  }
                  function apply(){
                    const b=getBtn(sel.value); if(!b) return;
                    const x=parseFloat(xIn.value)||0; const y=parseFloat(yIn.value)||0; const z=0;
                    b.dataset.position = `${x}m ${y}m ${z}m`;
                  }
                  sel.addEventListener('change',()=>load(sel.value));
                  btn.addEventListener('click',apply);
                  load(sel.value);
                })();
                </script>
  
              </div>
            </div>
  
            <div class="flow-left">
              <p id="flow-text" class="flow-mini-text">
                Der Linear Accelerator 4 (LINAC4) wurde 2020 offiziell in Betrieb genommen und ist der erste Schritt in der LHC-Beschleunigerkette. Er beschleunigt negativ geladene Wasserstoffionen (H⁻) auf eine Energie von 160 MeV, was etwa 0,43 % der Lichtgeschwindigkeit entspricht. Anschließend werden die Elektronen abgestreift, sodass reine Protonen entstehen. Der LINAC4 ersetzt den älteren LINAC2 und liefert einen dichteren und stärkeren Strahl. Er arbeitet als linearer Beschleuniger mit Radiofrequenz-Kavitäten. Die erzeugten Protonen werden anschließend in den Proton Synchrotron Booster eingespeist. LINAC4 bildet damit die Einspeisung für den gesamten weiteren Beschleunigerkomplex.
              </p>
              <div class="step-nav-fixed">
                <button class="step-btn" id="step-prev" type="button">◀ Zurück</button>
                <button class="step-btn" id="step-next" type="button">Weiter ▶</button>
              </div>
            </div>
          </div>
        </div>
      </section>
  
      <!-- ================= TEILCHENBESCHLEUNIGER (Bild-Hotspots) ================= -->
      <section class="section" id="ring-hotspots">
        <div class="container">
          <h2 class="reveal">Teilchenbeschleuniger allgemein</h2>
          <p class="reveal">Kurzer Überblick über die großen Experimente und ihre Positionen am Ring.</p>
          <div class="stage reveal" aria-label="LHC Übersicht">
            <img src="lhc-overview.jpg" alt="Ring-Übersicht des LHC" loading="lazy">
            <button class="hotspot" style="left:22%;top:60%" data-title="ATLAS" data-text="Allzweckdetektor." aria-label="Hotspot ATLAS"></button>
            <div class="fact" style="left:22%;top:60%"></div>
            <button class="hotspot" style="left:48%;top:25%" data-title="CMS" data-text="Allzweckdetektor." aria-label="Hotspot CMS"></button>
            <div class="fact" style="left:48%;top:25%"></div>
            <button class="hotspot" style="left:72%;top:63%" data-title="ALICE" data-text="Schwerionen-Fokus." aria-label="Hotspot ALICE"></button>
            <div class="fact" style="left:72%;top:63%"></div>
            <button class="hotspot" style="left:35%;top:78%" data-title="LHCb" data-text="Physik der b-Quarks." aria-label="Hotspot LHCb"></button>
            <div class="fact" style="left:35%;top:78%"></div>
          </div>
        </div>
      </section>
  
      <!-- ================= ATLAS ================= -->
      <section class="section" id="acceleration-chain">
        <div class="container">
          <h2 class="reveal">A Toroidal LHC Apparatus</h2>
          <p class="reveal">Eine Einführung in einen der 4 Detektoren des LHCs, Atlas</p>
        </div>
        <div class="clip-card">
          <div class="clip-box">
            <div class="clip-left">
              <h2 id="clip-title">Segment 1</h2>
              <p id="clip-text">Beschreibung Segment 1</p>
              <div class="clip-controls">
                <button id="btn-prev" class="step-btn" type="button">◀ Zurück</button>
                <button id="btn-next" class="step-btn" type="button">Weiter ▶</button>
              </div>
            </div>
        
            <div class="clip-right">
              <!-- sichtbare Layer -->
              <video id="vidA" playsinline muted preload="auto"></video>
              <video id="vidB" playsinline muted preload="auto"></video>
        
              <!-- unsichtbarer Preloader -->
              <video id="vidPre" playsinline muted preload="auto" style="display:none"></video>
        
              <div id="vfader"></div>
            </div>
          </div>
        </div>



      </section>
  
      <!-- ================= KOLLISIONEN ================= -->
      <section class="section" id="collision-detector">
        <div class="container">
          <h2 class="reveal">Kollisionen</h2>
          <p class="reveal">Visualisierung der Ringskalen (nur schematisch).</p>
          <div class="rings">
            <div class="detector" id="detector">
              <div class="layer" style="inset:auto; width:14%; height:14%; left:10%; top:94%; border-color:rgba(255,143,163,.9)" data-key="psb" title="PS Booster"></div>
              <div class="layer" style="inset:auto; width:26%; height:26%; left:48%; top:73.5%; border-color:rgba(167,139,250,.9)" data-key="ps" title="PS"></div>
              <div class="layer" style="inset:auto; width:58%; height:58%; left:38%; top:42%; border-color:rgba(255,209,102,.9)" data-key="sps" title="SPS"></div>
              <div class="layer" style="inset:auto; width:90%; height:90%; left:5%; top:5%; border-color:rgba(80,227,194,.95)" data-key="lhc" title="LHC"></div>
            </div>
            <div class="layers-legend" aria-label="Ringe einblenden">
              <div class="row"><div class="name">PS Booster</div><button type="button" data-target="psb">zeigen</button></div>
              <div class="row"><div class="name">PS</div><button type="button" data-target="ps">zeigen</button></div>
              <div class="row"><div class="name">SPS</div><button type="button" data-target="sps">zeigen</button></div>
              <div class="row"><div class="name">LHC</div><button type="button" data-target="lhc">zeigen</button></div>
            </div>
          </div>
        </div>
      </section>
  
      <!-- ================= SICHERHEIT ================= -->
      <section class="section" id="safety">
        <div class="container">
          <h2 class="reveal">Sicherheit und Realität</h2>
          <div class="safety">
            <div class="card reveal"><h3>Abschirmung</h3><p>Kurzinfo zu Strahlenschutz & Infrastruktur.</p></div>
            <div class="card reveal"><h3>Betrieb</h3><p>Kontrollierte Strahlzeiten & Wartungsphasen.</p></div>
            <div class="card reveal"><h3>Mythen</h3><p>Schwarze Löcher? Nope. Physikalisch nicht relevant.</p></div>
          </div>
        </div>
      </section>
  
      <!-- ================= QUELLEN ================= -->
      <section class="section" id="sources">
        <div class="container">
          <h2 class="reveal">Quellen</h2>
          <ul>
            <li><a href="#" style="color:#9ecbff">Beispielquelle 1</a></li>
            <li><a href="#" style="color:#9ecbff">Beispielquelle 2</a></li>
          </ul>
        </div>
      </section>
  
      <!-- === PONG OVERLAY =================================== -->
      <div id="pong-overlay" role="dialog" aria-modal="true" aria-label="Pong" hidden>
        <div id="pong-stage">
          <canvas id="pong-canvas" aria-label="Pong Spielfeld"></canvas>
        </div>
        <div id="pong-hud" class="container">
          <div class="pong-pill">Score: <span id="pong-score">0</span></div>
          <div class="pong-pill">Highscore: <span id="pong-best">0</span></div>
          <div class="pong-pill pong-muted">Toggle: Alt+P · Pause/Resume: P · Steuerung: Pfeile/W-S</div>
          <button id="pong-close" type="button" title="Schließen (Alt+P)">Schließen</button>
        </div>
      </div>
    </div>
    
    <!-- DVD-Bounce-Box -->
    <div id="dvd-wrap" aria-hidden="true">
      <div id="dvd-box">
        <iframe
          id="dvd-iframe"
          src="https://www.youtube.com/embed/RATozKcpDc4?autoplay=1&mute=1&controls=0&loop=1&playlist=RATozKcpDc4&modestbranding=1&rel=0&playsinline=1"
          title="screensaver"
          frameborder="0"
          allow="autoplay; encrypted-media"
          style="width:320px;height:180px;pointer-events:none;">
        </iframe>
      </div>
    </div>

    



    <!-- ================= SCRIPTS ================= -->
    <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>

    <script defer>
      const ioReveal = new IntersectionObserver((es)=>{es.forEach(e=>{if(e.isIntersecting)e.target.classList.add('show')})},{threshold:.2});
      document.querySelectorAll('.reveal').forEach(x=>ioReveal.observe(x));
    </script>

    <script defer>
      const hotspots = [...document.querySelectorAll('.hotspot')];
      const facts = hotspots.map(h => h.nextElementSibling);
      hotspots.forEach(h => {
        const fact = h.nextElementSibling;
        h.addEventListener('click', () => {
          facts.forEach(x => x.classList.remove('show'));
          fact.innerHTML = `<h3>${h.dataset.title}</h3><p>${h.dataset.text}</p>`;
          fact.classList.add('show');
        });
      });
      document.addEventListener('click', (ev) => {
        if (!hotspots.some(h => h.contains(ev.target)) &&
            !facts.some(f => f.contains(ev.target))) {
          facts.forEach(f => f.classList.remove('show'));
        }
      });
    </script>

    <script defer>
      (function(){
        const stepsEl = document.getElementById('phys-steps');
        const stepLis = stepsEl.querySelectorAll('li');
        const energy = document.getElementById('energy');
        const speed  = document.getElementById('speed');
        const turns  = document.getElementById('turns');
        const vals=[{e:1,s:1,t:1},{e:2,s:2,t:3},{e:3,s:3,t:6},{e:5,s:4,t:10},{e:8,s:5,t:16},{e:13,s:6,t:24}];
        function setStep(i){
          stepLis.forEach(li=>li.classList.remove('active'));
          stepLis[i].classList.add('active');
          energy.textContent=vals[i].e; speed.textContent=vals[i].s; turns.textContent=vals[i].t;
        }
        stepLis.forEach((li,i)=>li.addEventListener('click',()=>setStep(i)));
        const section=document.getElementById('acceleration-chain'); let last=0;
        document.addEventListener('scroll',()=>{
          const r=section.getBoundingClientRect();
          if(r.top<window.innerHeight*0.6 && r.bottom>window.innerHeight*0.4){
            const p=(window.innerHeight*0.6-r.top)/(r.height+window.innerHeight*0.2);
            const idx=Math.max(0,Math.min(5,Math.floor(p*6)));
            if(idx!==last){ setStep(idx); last=idx; }
          }
        });
        const b = document.getElementById('bfield');
        const bval = document.getElementById('bval');
        const beam = document.getElementById('beam');
        function upd(){
          const v=+b.value; bval.textContent=v+'%';
          const minR=90,maxR=240; const R=maxR-(v/100)*(maxR-minR);
          const cx=160,cy=160; const ang=Math.min(110,3800/R); const rad=ang*Math.PI/180;
          const startX=20,startY=160;
          const endX=cx+R*Math.sin(rad)-(R-(cx-startX));
          const endY=cy-R*(1-Math.cos(rad));
          const large=ang>180?1:0;
          beam.setAttribute('d',`M ${startX} ${startY} A ${R} ${R} 0 ${large} 1 ${endX} ${endY}`);
        }
        b.addEventListener('input',upd); upd();
      })();
    </script>

    <script defer>
      (function(){
        const events=[
          {date:'1949',title:'CERN Vorschlag',text:'Louis de Broglie schlug auf der Europäischen Kulturkonferenz in Lausanne die Gründung eines europäischen Physiklaboratoriums vor.',img:'14-fascinating-facts-about-louis-de-broglie-1696476450.jpg',link:'https://de.wikipedia.org/wiki/Louis_de_Broglie'},
          {date:'1952',title:'Offizielle Gründung Cerns',text:'11 Regierungen unterzeichneten in Genf ein Abkommen zur Gründung des “Conseil Européen pour la Recherche Nucléaire” kurz CERN.',img:'OIP.webp',link:'https://de.wikipedia.org/wiki/CERN#Gr%C3%BCndung'},
          {date:'1959',title:'Protonensynchrotron Rekord',text:'Das Protonensynchrotron erreichte 24 GeV und wurde damit zum leistungsstärksten Beschleuniger der Welt zur damaligen Zeit.',img:'OIP (1).webp',link:'https://timeline.web.cern.ch/proton-synchrotron-starts'},
          {date:'1968',title:'Drahtkammer erfunden',text:'Georges Charpak entwickelt einen neuen Teilchendetektor mit hoher Auflösung; 1992 gab’s den Nobelpreis.',img:'OIP (3).webp',link:'https://de.wikipedia.org/wiki/CERN#Erste_Beschleuniger'},
          {date:'1976',title:'Super Synchrotron gestartet',text:'Der Super Proton Synchrotron (SPS) startete mit 400 GeV, später auf 500 GeV aufgerüstet.',img:'IMG_0496.jpeg',link:'https://timeline.web.cern.ch/super-proton-synchrotron-starts'},
          {date:'1989',title:'LEP gestartet',text:'Der Large Electron-Positron Collider (LEP) nahm den Betrieb auf. 27 km Tunnel, Elektronen–Positronen bis 100 GeV.',img:'IMG_0507.jpeg',link:'https://timeline.web.cern.ch/large-electron-positron-collider-first-injection'},
          {date:'1996',title:'Antiwasserstoff erzeugt',text:'Am LEAR-Speicherring wurden erstmals Antiwasserstoff-Atome hergestellt.',img:'IMG_0509.jpeg',link:'https://de.wikipedia.org/wiki/CERN#Large_Electron-Positron_Collider'},
          {date:'2000',title:'LEP abgeschaltet – LHC-Bau',text:'LEP wird stillgelegt, der LHC-Bau im selben Tunnel beginnt.',img:'IMG_0511.jpeg',link:'https://timeline.web.cern.ch/leps-final-shutdown'},
          {date:'2008',title:'LHC gestartet',text:'Erster Protonenstrahl erfolgreich durch den 27-km-LHC gelenkt.',img:'IMG_0512.jpeg',link:'https://timeline.web.cern.ch/lhc-starts'}
        ];
        const labels = document.getElementById('tl-labels');
        const pips   = document.getElementById('tl-pips');
        const bar    = document.getElementById('tl-bar');
        const marker = document.getElementById('tl-marker');
        const animWrap = document.querySelector('.event-card .anim-wrap');
        const prevBtn = document.querySelector('.prev');
        const nextBtn = document.querySelector('.next');
        labels.innerHTML = events.map(e=>`<div>${e.date}</div>`).join('');
        function layoutPips(){
          const w=bar.offsetWidth; pips.innerHTML='';
          const steps=events.length-1||1;
          events.forEach((e,i)=>{
            const x=(i*(w/steps));
            const d=document.createElement('button');
            d.className='pip'; d.type='button'; d.style.left=`${x}px`; d.title=e.date; d.setAttribute('aria-label',e.date);
            d.addEventListener('click',()=>goTo(i));
            pips.appendChild(d);
          });
        }
        window.addEventListener('resize',()=>{ setMarker(idx); layoutPips(); });
        let idx=0; let busy=false;
        function slideTemplate(e){
          return `
            <div class="slide">
              <div class="event-media"><img src="${e.img}" alt="${e.title} Bild"></div>
              <div class="event-info">
                <div class="date">${e.date}</div>
                <h3>${e.title}</h3>
                <p>${e.text}</p>
                <a href="${e.link}" target="_blank" rel="noopener noreferrer">Mehr erfahren</a>
              </div>
            </div>`;
        }
        function setMarker(i){
          const w=bar.offsetWidth; const steps=events.length-1||1; const x=(i*(w/steps));
          marker.style.transform=`translate(${x-8}px, -50%)`;
          [...pips.children].forEach((p,pi)=>p.classList.toggle('active',pi===i));
        }
        function updateButtons(){
          prevBtn.disabled = (idx===0);
          nextBtn.disabled = (idx===events.length-1);
        }
        function show(i){
          if(busy) return; busy=true;
          const leaving=animWrap.querySelector('.slide');
          if(leaving){ leaving.classList.add('leave'); leaving.addEventListener('animationend',()=>leaving.remove(),{once:true}); }
          const frag=document.createElement('div'); frag.innerHTML=slideTemplate(events[i]);
          const entering=frag.firstElementChild; entering.classList.add('enter');
          animWrap.appendChild(entering);
          setMarker(i); updateButtons();
          entering.addEventListener('animationend',()=>{busy=false;},{once:true});
        }
        function goTo(i){ if(i<0||i>events.length-1) return; idx=i; show(idx); }
        function go(n){ goTo(idx+n); }
        layoutPips();
        show(idx);
        prevBtn.addEventListener('click',()=>go(-1));
        nextBtn.addEventListener('click',()=>go(1));
        window.addEventListener('keydown',e=>{ if(e.key==='ArrowLeft') go(-1); if(e.key==='ArrowRight') go(1); });
      })();
    </script>

    <script defer>
      (function(){
        const acc = document.getElementById('cern-accordion');
        if(!acc) return;
        const btn   = acc.querySelector('.accordion-header');
        const panel = document.getElementById('cern-accordion-content');
        const inner = panel.querySelector('.accordion-inner');
        function openPanel(){
          acc.classList.add('open');
          btn.setAttribute('aria-expanded','true');
          panel.style.height = 'auto';
          const target = panel.scrollHeight;
          panel.style.height = '0px';
          requestAnimationFrame(()=>{ requestAnimationFrame(()=>{ panel.style.height = target + 'px'; }); });
        }
        function closePanel(){
          btn.setAttribute('aria-expanded','false');
          panel.style.height = panel.scrollHeight + 'px';
          requestAnimationFrame(()=>{ panel.style.height = '0px'; });
          acc.classList.remove('open');
        }
        btn.addEventListener('click', ()=>{ const willOpen = !acc.classList.contains('open'); if(willOpen) openPanel(); else closePanel(); });
        panel.addEventListener('transitionend', (e)=>{ if(e.propertyName!=='height') return; if(acc.classList.contains('open')) panel.style.height='auto'; });
        const io = new IntersectionObserver((entries)=>{ entries.forEach(entry=>{ if(entry.intersectionRatio < 0.2 && acc.classList.contains('open')) closePanel(); }); },{threshold:[0,0.2,1]});
        io.observe(acc);
        const ro = new ResizeObserver(()=>{ if(acc.classList.contains('open') && panel.style.height!=='auto'){ panel.style.height = inner.getBoundingClientRect().height + 'px'; } });
        ro.observe(inner);
        function highlight(hash){
          if(!hash) return;
          const el=document.querySelector(hash);
          if(!el) return;
          el.classList.remove('flash');
          requestAnimationFrame(()=>{ el.classList.add('flash'); });
          setTimeout(()=>el.classList.remove('flash'), 1300);
        }
        document.querySelectorAll('a[href^="#"]').forEach(a=>{
          a.addEventListener('click',(e)=>{
            const hash=a.getAttribute('href'); const target=document.querySelector(hash);
            if(!target) return;
            e.preventDefault();
            target.scrollIntoView({behavior:'smooth', block:'start'});
            history.pushState(null,"",hash);
            highlight(hash);
          });
        });
        if(location.hash){ setTimeout(()=>highlight(location.hash), 300); }
        window.addEventListener('hashchange', ()=>highlight(location.hash));
      })();
    </script>

    <!-- PONG omitted: unchanged from your version -->
    <script defer>
      (function(){
        const overlay = document.getElementById('pong-overlay');
        const canvas  = document.getElementById('pong-canvas');
        const scoreEl = document.getElementById('pong-score');
        const bestEl  = document.getElementById('pong-best');
        const closeBtn= document.getElementById('pong-close');
        const LS_KEY = 'pong_highscore_v1';
        const best = +localStorage.getItem(LS_KEY) || 0;
        bestEl.textContent = best;
        function isOpen(){ return !overlay.hasAttribute('hidden'); }
        function open(){ if(isOpen()) return; overlay.removeAttribute('hidden'); document.body.style.overflow='hidden'; resizeCanvas(); window.__PONG__?._start?.(); }
        function close(){ if(!isOpen()) return; overlay.setAttribute('hidden',''); document.body.style.overflow=''; window.__PONG__?._stop?.(); }
        window.addEventListener('keydown', (ev)=>{ if(ev.altKey && (ev.key.toLowerCase()==='p')){ ev.preventDefault(); isOpen() ? close() : open(); } else if(isOpen() && (ev.key.toLowerCase()==='p')){ ev.preventDefault(); window.__PONG__?._togglePause?.(); } });
        closeBtn.addEventListener('click', close);
        const ctx = canvas.getContext('2d');
        function resizeCanvas(){ const dpr = Math.max(1, window.devicePixelRatio || 1); const cssW = canvas.clientWidth; const cssH = canvas.clientHeight; canvas.width  = Math.floor(cssW * dpr); canvas.height = Math.floor(cssH * dpr); ctx.setTransform(dpr,0,0,dpr,0,0); }
        window.addEventListener('resize', ()=>{ if(isOpen()) resizeCanvas(); });
        window.__PONG__ = { open, close, isOpen, ctx, canvas, scoreEl, bestEl, LS_KEY, resizeCanvas };
      })();
    </script>

    <script defer>
      (function(){
        const { isOpen, ctx, canvas, scoreEl, bestEl, LS_KEY, resizeCanvas } = window.__PONG__;
        const WORLD  = { w: 900, h: 600, pad: 18 };
        const PADDLE = { w: 14, h: 110, x: 28, y: 300, speed: 10 };
        const BALL   = { x: 450, y: 300, r: 8, vx: 5, vy: 3.2, base: 8.0 };
        const RAMP_PER_SEC = 0.1;
        let raf = null, paused = false, running = false;
        let score = 0, best = +bestEl.textContent || 0;
        const keys = new Set();
        window.addEventListener('keydown', e=>{ if(!isOpen()) return; if(['ArrowUp','ArrowDown','w','s','W','S'].includes(e.key)) { keys.add(e.key); e.preventDefault(); } });
        window.addEventListener('keyup', e=>{ keys.delete(e.key); });
        function resetBall(dir = 1){
          BALL.x  = WORLD.w * 0.5;
          BALL.y  = WORLD.h * 0.5;
          const angle = (Math.random()*0.6 - 0.3);
          const speed = BALL.base;
          BALL.vx = dir * speed * Math.cos(angle);
          BALL.vy = speed * Math.sin(angle);
        }
        function speedUp(f=1.05){ BALL.vx *= f; BALL.vy *= f; }
        function start(){ if(running) return; running = true; paused = false; score = 0; scoreEl.textContent = '0'; resetBall(Math.random()<0.5 ? 1 : -1); resizeCanvas(); loop(); }
        function stop(){ running = false; if(raf){ cancelAnimationFrame(raf); raf=null; } }
        function togglePause(){ if(!running) return; paused = !paused; if(!paused) loop(); drawHUD(); }
        let lastT = 0;
        function loop(ts=0){
          if(!running) return;
          raf = requestAnimationFrame(loop);
          const dtMs = ts - (lastT||ts);
          lastT = ts;
          const dt = Math.min(33, Math.max(0, dtMs)) / 16.67;
          update(dt); draw();
        }
        function update(dt){
          const up = keys.has('ArrowUp') || keys.has('w') || keys.has('W');
          const dn = keys.has('ArrowDown') || keys.has('s') || keys.has('S');
          if(up && !dn)   PADDLE.y -= PADDLE.speed * dt * 1.2;
          if(dn && !up)   PADDLE.y += PADDLE.speed * dt * 1.2;
          PADDLE.y = Math.max(PADDLE.h/2, Math.min(WORLD.h - PADDLE.h/2, PADDLE.y));
          if(paused) return;
          const factor = 1 + (RAMP_PER_SEC * (dt/60));
          BALL.vx *= factor; BALL.vy *= factor;
          BALL.x += BALL.vx * dt; BALL.y += BALL.vy * dt;
          if(BALL.y - BALL.r < 0){ BALL.y = BALL.r; BALL.vy *= -1; }
          if(BALL.y + BALL.r > WORLD.h){ BALL.y = WORLD.h - BALL.r; BALL.vy *= -1; }
          if(BALL.x + BALL.r > WORLD.w){ BALL.x = WORLD.w - BALL.r; BALL.vx *= -1; }
          const padLeft = PADDLE.x, padRight = PADDLE.x + PADDLE.w;
          const padTop  = PADDLE.y - PADDLE.h/2, padBot = PADDLE.y + PADDLE.h/2;
          if(BALL.x - BALL.r < padRight && BALL.x + BALL.r > padLeft &&
             BALL.y + BALL.r > padTop && BALL.y - BALL.r < padBot && BALL.vx < 0){
            const rel = (BALL.y - PADDLE.y) / (PADDLE.h/2);
            BALL.x = padRight + BALL.r;
            const speed = Math.hypot(BALL.vx, BALL.vy) * 1.04;
            const maxAngle = Math.PI * 0.35;
            const angle = rel * maxAngle;
            BALL.vx =  Math.cos(angle) * speed;
            BALL.vy =  Math.sin(angle) * speed;
            score += 1; scoreEl.textContent = String(score);
            if(score % 5 === 0) speedUp(1.06);
          }
          if(BALL.x + BALL.r < 0){
            if(score > best){ best = score; bestEl.textContent = String(best); try{ localStorage.setItem(LS_KEY, String(best)); }catch{} }
            score = 0; scoreEl.textContent='0';
            resetBall(+1); BALL.vx *= 0.85; BALL.vy *= 0.85;
          }
        }
        function draw(){
          const cssW = canvas.clientWidth, cssH = canvas.clientHeight;
          const ctx = window.__PONG__.ctx;
          ctx.clearRect(0,0,cssW,cssH);
          ctx.strokeStyle = '#2b2d33'; ctx.lineWidth = 2; ctx.strokeRect(0,0,cssW,cssH);
          ctx.setLineDash([8,16]); ctx.lineDashOffset = 2;
          ctx.beginPath(); ctx.moveTo(cssW/2, 0); ctx.lineTo(cssW/2, cssH);
          ctx.strokeStyle = 'rgba(255,255,255,.18)'; ctx.lineWidth = 3; ctx.stroke();
          ctx.setLineDash([]);
          ctx.fillStyle = '#ffffff'; ctx.font = '700 28px Inter, system-ui, sans-serif'; ctx.textAlign = 'center';
          ctx.fillText(String(score), cssW/2, 36);
          const padScaleX = cssW / WORLD.w, padScaleY = cssH / WORLD.h;
          const px = PADDLE.x * padScaleX, py = PADDLE.y * padScaleY;
          const pw = PADDLE.w * padScaleX, ph = PADDLE.h * padScaleY;
          ctx.fillStyle = '#e5e7eb'; roundRect(ctx, px, py - ph/2, pw, ph, 8); ctx.fill();
          const bx = BALL.x * padScaleX, by = BALL.y * padScaleY;
          const br = BALL.r * ((padScaleX + padScaleY)/2);
          ctx.beginPath(); ctx.arc(bx, by, br, 0, Math.PI*2);
          ctx.fillStyle = '#ffffff'; ctx.shadowColor = 'rgba(255,255,255,.2)'; ctx.shadowBlur = 8; ctx.fill(); ctx.shadowBlur = 0;
          if(paused) drawHUD(true);
        }
        function drawHUD(pausedOnly=false){
          if(!pausedOnly) return;
          const cssW = canvas.clientWidth, cssH = canvas.clientHeight;
          const ctx = window.__PONG__.ctx;
          ctx.fillStyle = 'rgba(0,0,0,.45)'; ctx.fillRect(0,0,cssW,cssH);
          ctx.fillStyle = '#fff'; ctx.font = '700 28px Inter, system-ui, sans-serif'; ctx.textAlign = 'center';
          ctx.fillText('PAUSE – P zum Fortsetzen', cssW/2, cssH/2);
        }
        function roundRect(ctx, x, y, w, h, r){
          const rr = Math.min(r, w/2, h/2);
          ctx.beginPath();
          ctx.moveTo(x+rr, y);
          ctx.arcTo(x+w, y, x+w, y+h, rr);
          ctx.arcTo(x+w, y+h, x, y+h, rr);
          ctx.arcTo(x, y+h, x, y, rr);
          ctx.arcTo(x, y, x+w, y, rr);
          ctx.closePath();
        }
        window.__PONG__._start = start;
        window.__PONG__._stop = stop;
        window.__PONG__._togglePause = togglePause;
      })();
    </script>

    <!-- Beschleunigerkette: Buttons & Texte + CAMERA FOCUS (smooth) -->
    <script defer>
      (function(){
        const elTitle = document.getElementById('flow-title');
        const elText  = document.getElementById('flow-text');
        const modePro = document.getElementById('mode-protons');
        const modeIon = document.getElementById('mode-ions');
        const prevBtn = document.getElementById('step-prev');
        const nextBtn = document.getElementById('step-next');

        const protons = [
          { key:'Linear Accelerator 4 (LINAC4)', text:'Der Linear Accelerator 4 (LINAC4) wurde 2020 offiziell in Betrieb genommen und ist der erste Schritt in der LHC-Beschleunigerkette. Er beschleunigt negativ geladene Wasserstoffionen (H⁻) auf eine Energie von 160 MeV, was etwa 0,43 % der Lichtgeschwindigkeit entspricht. Anschließend werden die Elektronen abgestreift, sodass reine Protonen entstehen. Der LINAC4 ersetzt den älteren LINAC2 und liefert einen dichteren und stärkeren Strahl. Er arbeitet als linearer Beschleuniger mit Radiofrequenz-Kavitäten. Die erzeugten Protonen werden anschließend in den Proton Synchrotron Booster eingespeist. LINAC4 bildet damit die Einspeisung für den gesamten weiteren Beschleunigerkomplex.' },
          { key:'Proton Synchrotron Booster (PSB)', text:'Der Proton Synchrotron Booster (PSB) wurde 1972 in Betrieb genommen und ist die zweite Stufe nach dem LINAC4. Er übernimmt Protonen, die aus LINAC4 mit 160 MeV kommen, und beschleunigt sie auf 2 GeV. Der PSB besteht aus vier übereinanderliegenden Ringen, die gleichzeitig genutzt werden, um mehrere Strahlenpakete aufzubauen. Er arbeitet als Synchrotron mit Magnetfeldern zur Führung und Radiofrequenz-Kavitäten zur Beschleunigung. Der Booster erhöht nicht nur die Energie, sondern auch die Intensität und Qualität des Strahls. Die Protonen aus dem PSB werden anschließend an das Proton Synchrotron (PS) weitergegeben. ' },
          { key:'Proton Synchrotron (PS)',         text:'Das Proton Synchrotron (PS) ging 1959 in Betrieb und war damals der größte Beschleuniger der Welt. Es übernimmt Protonen mit 2 GeV vom PS Booster und beschleunigt sie auf 26 GeV. Mit einem Umfang von 628 m ist es ein Synchrotron, das Magnetfelder und Radiofrequenz-Felder nutzt. Neben Protonen können auch schwere Ionen beschleunigt werden, die aus speziellen Ionenquellen kommen. Das PS bereitet die Strahlen für verschiedene Zwecke vor: ein Teil geht direkt an Experimente am CERN (z. B. Neutrino-, Antiproton- oder Festkörperphysik), ein anderer Teil wird an das Super Proton Synchrotron (SPS) weitergeleitet. Damit ist das PS eine Art Verteilstation im CERN-Komplex. ' },
          { key:'Super Proton Synchrotron (SPS)',        text:'Das Super Proton Synchrotron (SPS) wurde 1976 in Betrieb genommen und übernimmt Protonen oder Ionen vom PS mit 26 GeV. Es beschleunigt sie auf bis zu 450 GeV. Mit einem Umfang von 6,9 km ist es einer der größten Synchrotrons am CERN. Neben Protonen werden hier auch schwere Ionen wie Bleiionen beschleunigt, die in den PS eingespeist wurden. Der SPS lieferte früher auch Strahlen für Eigenexperimente (z. B. Neutrinos nach Gran Sasso oder WA-Experimente). Heute ist er vor allem dafür zuständig, die Strahlenpakete für den Large Hadron Collider (LHC) vorzubereiten und dort einzuspeisen. Er ist damit die letzte Stufe vor dem eigentlichen Hochenergie-Collider.' },
          { key:'Large Hadron Collider (LHC)',        text:'Kollisionen bei sehr hoher Schwerpunktsenergie.' }
        ];

        let mode = 'protons';
        let i = 0;
        const seq = () => (mode==='protons' ? protons : ions);
       
        function stepToHotspotName(stepKey){
          const s = String(stepKey).toLowerCase().trim();
        
          if (s.includes('linac4')) return 'LINAC4';
        
          // Booster BEFORE generic PS
          if (s.includes('(psb') || s.includes('booster')) return 'PSBooster';
        
          // SPS BEFORE generic PS (catch both token and full name)
          if (/\bsps\b/.test(s) || s.includes('super proton synchrotron')) return 'SPS';
        
          // Generic PS last
          if (/\bps\b/.test(s) || s.includes(' proton synchrotron')) return 'PS';
        
          if (/\blhc\b/.test(s)) return 'LHC';
        
          return null;
        }


        function fade(el, text, dur=180){
          const RDM = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
          if(RDM){ el.textContent = text; return; }
          el.animate([{opacity:1},{opacity:.2}],{duration:dur,easing:'ease'}).onfinish=()=>{
            el.textContent = text;
            el.animate([{opacity:.2},{opacity:1}],{duration:dur,easing:'ease'});
          };
        }

        async function render(){
          const step = seq()[i];
          fade(elTitle, step.key);
          fade(elText,  step.text);
          prevBtn.disabled = (i===0);
          nextBtn.disabled = (i===seq().length-1);

          const hotspotName = stepToHotspotName(step.key);
          if(hotspotName && window.__MV_FOCUS__){
            await window.__MV_FOCUS__.focusTo(hotspotName, 900);
          }
        }

        function setMode(m){
          if(mode===m) return;
          mode = m; i = 0;
          modePro.classList.toggle('active', mode==='protons');
          modeIon.classList.toggle('active', mode==='ions');
          render();
        }

        modePro?.addEventListener('click', ()=>setMode('protons'));
        modeIon?.addEventListener('click', ()=>setMode('ions'));
        prevBtn?.addEventListener('click', ()=>{ if(i>0){ i--; render(); } });
        nextBtn?.addEventListener('click', ()=>{ const max=seq().length-1; if(i<max){ i++; render(); } });

        render();
      })();
    </script>

    <script>
     (function(){
        const wrap    = document.getElementById('dvd-wrap');
        const box     = document.getElementById('dvd-box');
        const content = document.getElementById('content-wrap'); // we'll blur this
      
        const IDLE_MS = 20000;
        let x = 40, y = 40;
        let vx = 1.1, vy = 0.85;
        let bw = 320, bh = 180;
        let raf = null, idleTimer = null, saverOn = false;
      
        function step(){
          const W = window.innerWidth;
          const H = window.innerHeight;
          x += vx; y += vy;
      
          if (x <= 0 || x + bw >= W) { vx *= -1; x = Math.max(0, Math.min(W - bw, x)); }
          if (y <= 0 || y + bh >= H) { vy *= -1; y = Math.max(0, Math.min(H - bh, y)); }
      
          box.style.transform = `translate(${x}px, ${y}px)`;
          raf = requestAnimationFrame(step);
        }
      
        function startSaver(){
          if (saverOn) return;
          saverOn = true;
          wrap.classList.add('active');    
          content.classList.add('blur');   
          step();
        }
      
        function stopSaver(){
          if (!saverOn) return;
          saverOn = false;
          wrap.classList.remove('active'); // fade out overlay
          content.classList.remove('blur');// unblur background
          cancelAnimationFrame(raf);
        }
      
        function resetIdleTimer(){
          stopSaver();
          if (idleTimer) clearTimeout(idleTimer);
          idleTimer = setTimeout(startSaver, IDLE_MS);
        }
      
        // mousemove intentionally NOT included
        const resetEvents = ['mousemove','mousedown','keydown','touchstart','scroll','pointerdown','wheel'];
        resetEvents.forEach(ev => window.addEventListener(ev, resetIdleTimer, { passive:true }));
      
        wrap.addEventListener('click', stopSaver);
        window.addEventListener('keydown', stopSaver);
      
        document.addEventListener('visibilitychange', () => {
          if (document.hidden) stopSaver();
          else resetIdleTimer();
        });
      
        resetIdleTimer();
      })();

    </script>


    <script>
      (function(){
        // ==== Stops (frames) ====
        const STOPS = [0,130,230,320,440,600,760,830,930,1020,1100,1210,1310,1420];
        // Segments are [startFrame, endFrame, title, text]
        const FRAMES = STOPS.slice(0, -1).map((s, idx) => [
          s, STOPS[idx + 1], `Segment ${idx + 1}`, `Beschreibung Segment ${idx + 1}`
        ]);
      
        const FPS = 30;
        const FRAME = 1 / FPS;
        const EPS = 0.002; // tiny guard to avoid frame 0 quirks
        const toT = f => f / FPS;
      
        // DOM
        const v       = document.getElementById('clip-video');
        const prevBtn = document.getElementById('btn-prev');
        const nextBtn = document.getElementById('btn-next');
        const titleEl = document.getElementById('clip-title');
        const textEl  = document.getElementById('clip-text');
        const fader   = document.getElementById('vfader');
      
        // State
        let i = 0;
        let busy = false;
        let forwardTimer = null;
        let reverseTimer = null;         // <— NEU
        function clearTimers(){          // <— NEU
          if (forwardTimer) { clearInterval(forwardTimer); forwardTimer = null; }
          if (reverseTimer) { clearInterval(reverseTimer); reverseTimer = null; }
        }

        async function playThenFreezeNext(idx){
        if (busy) return;
        busy = true; setButtons();
        clearTimers();                 // <— NEU

        }


        // Helpers
        function fadeOn(){ fader.classList.add('fade'); }
        function fadeOff(){ fader.classList.remove('fade'); }
        const once = (el, ev) => new Promise(res => el.addEventListener(ev, res, { once:true }));
      
        async function seekTo(t){
          fadeOn();
          v.pause();
          v.currentTime = Math.max(EPS, t);
          // Wait just until browser says we're at that position
          await once(v, 'seeked');
          // Let a frame paint, then fade out
          requestAnimationFrame(() => fadeOff());
        }
      
        function setCopy(){ titleEl.textContent = FRAMES[i][2]; textEl.textContent = FRAMES[i][3]; }
        function setButtons(){
          prevBtn.disabled = (i === 0) || busy;
          nextBtn.disabled = (i >= FRAMES.length - 1) || busy;
        }
      
        async function freezeAtStart(idx){
          await seekTo(toT(FRAMES[idx][0]) + EPS);
        }
      
        // ------- Forward (play to endT precisely) -------
        async function playThenFreezeNext(idx){
          if (busy) return;
          busy = true; setButtons();
      
          const startT = toT(FRAMES[idx][0]) + EPS;
          const endT   = toT(FRAMES[idx][1]) - EPS;
      
          await seekTo(startT);
      
          // Use requestVideoFrameCallback if supported
          if ('requestVideoFrameCallback' in v) {
            let stop = false;
            const onFrame = () => {
              if (stop) return;
              // Stop exactly at endT
              if (v.currentTime >= endT) {
                v.pause();
                // snap to exact boundary to avoid “half frame”
                v.currentTime = endT;
                stop = true;
                v.requestVideoFrameCallback(() => {
                  // advance to next segment and freeze at its start
                  if (idx < FRAMES.length - 1) {
                    i = idx + 1;
                    freezeAtStart(i).then(()=>{ setCopy(); busy = false; setButtons(); });
                  } else {
                    busy = false; setButtons();
                  }
                });
                return;
              }
              v.requestVideoFrameCallback(onFrame);
            };
            // start playback then frame-watch
            try { await v.play(); } catch {}
            v.requestVideoFrameCallback(onFrame);
          } else {
            // Fallback: high-rate interval watcher
            try { await v.play(); } catch {}
            forwardTimer && clearInterval(forwardTimer);
            forwardTimer = setInterval(() => {
              if (v.currentTime >= endT) {
                clearInterval(forwardTimer);
                v.pause();
                v.currentTime = endT;
                // advance to next
                if (idx < FRAMES.length - 1) {
                  i = idx + 1;
                  freezeAtStart(i).then(()=>{ setCopy(); busy = false; setButtons(); });
                } else {
                  busy = false; setButtons();
                }
              }
            }, 16); // ~60Hz
          }
        }
      
  
        // ------- Reverse (rAF-basiert + fastSeek) -------
        async function reversePrev(){
          if (busy || i === 0) return;
          busy = true; setButtons();
          clearTimers();
        
          const prevIdx = i - 1;
          const startT = toT(FRAMES[prevIdx][0]) + EPS;
          const endT   = toT(FRAMES[prevIdx][1]) - EPS;
        
          await seekTo(endT);
          v.pause();
        
          let t = endT;
          let running = true;
        
          const BASE_STEP = FRAME * 0.85; // vorsichtig kleiner als 1/FPS
          let step = BASE_STEP;
        
          function stepBack() {
            if (!running) return;
        
            // Adaptiv etwas größer/kleiner machen je nach readyState
            // (wenn Decoder hinterherhinkt, kleinere Schritte)
            if (v.readyState < 2 && step > FRAME * 0.5) step *= 0.9;
            else if (v.readyState >= 3 && step < FRAME * 1.2) step *= 1.02;
        
            t -= step;
            if (t <= startT + 0.0005) {
              t = startT;
              running = false;
            }
        
            // Prefer fastSeek if supported
            if (typeof v.fastSeek === 'function') {
              try { v.fastSeek(t); } catch { v.currentTime = t; }
            } else {
              v.currentTime = t;
            }
        
            if (running) {
              requestAnimationFrame(stepBack);
            } else {
              // Am Start „einrasten“
              requestAnimationFrame(() => {
                v.currentTime = startT;
                i = prevIdx;
                busy = false;
                setCopy(); setButtons();
              });
            }
          }
        
          requestAnimationFrame(stepBack);
        }


      
        // Wire up
        nextBtn.addEventListener('click', () => playThenFreezeNext(i));
        prevBtn.addEventListener('click', reversePrev);
        window.addEventListener('keydown', e => {
          if (e.key === 'ArrowLeft')  { e.preventDefault(); reversePrev(); }
          if (e.key === 'ArrowRight' || e.key === 'Enter') { e.preventDefault(); playThenFreezeNext(i); }
        });
      
        // Init
        v.addEventListener('loadedmetadata', () => freezeAtStart(i), { once:true });
        v.load();
        setCopy(); setButtons();
      })();
    </script>
    <script>
      (function(){
        // ====== Pfad & Segmente ===================================================
        const BASE = 'ATLAS/'; // <- dein Ordner
        const SEGMENTS = Array.from({length:14}, (_,k) => {
          const n = k+1;
          return {
            title: `Segment ${n}`,
            text:  `Beschreibung Segment ${n}`,
            fwd:   `${BASE}${n}.mp4`,
            rev:   `${BASE}${n}-${n}.mp4`
          };
        });
      
        // ====== DOM ===============================================================
        const titleEl = document.getElementById('clip-title');
        const textEl  = document.getElementById('clip-text');
        const btnPrev = document.getElementById('btn-prev');
        const btnNext = document.getElementById('btn-next');
      
        const A   = document.getElementById('vidA');   // sichtbarer Layer
        const B   = document.getElementById('vidB');   // sichtbarer Layer
        const PRE = document.getElementById('vidPre'); // unsichtbarer Preload-Buffer
        const fader = document.getElementById('vfader');
      
        let active = A; // aktuell sichtbares Video
        let back   = B; // zweiter Layer
        let i = 0;      // aktueller Segmentindex
        let busy = false;
      
        // ====== Helpers ===========================================================
        const once = (el, ev, opts={}) => new Promise(res => el.addEventListener(ev, res, { once:true, ...opts }));
      
        function setCopy(idx){
          titleEl.textContent = SEGMENTS[idx].title;
          textEl.textContent  = SEGMENTS[idx].text;
        }
        function setButtons(){
          btnPrev.disabled = busy || (i===0);
          btnNext.disabled = busy || (i===SEGMENTS.length-1);
        }
        function fadeOn(){ fader.classList.add('fade'); }
        function fadeOff(){ fader.classList.remove('fade'); }
      
        function setSrc(videoEl, url){
          // vorhandene <source>-Kinder leeren
          while(videoEl.firstChild) videoEl.removeChild(videoEl.firstChild);
          videoEl.removeAttribute('src'); // sichergehen
          // einfache Quelle (MP4). Falls du WebM mitliefern willst: hier 2 <source> anhängen.
          videoEl.src = url;
        }
      
        async function primeAtStart(videoEl){
          // an den Anfang -> kurz anspielen -> pausieren (Decoder warm)
          try { videoEl.pause(); } catch{}
          videoEl.currentTime = 0;
          // Warten bis wirklich seeked
          await Promise.race([ once(videoEl,'seeked'), new Promise(r=>setTimeout(r,120)) ]);
          try { await videoEl.play(); } catch {} // muted+inline sollte gehen
          // ein Frame „ziehen“
          await Promise.race([ once(videoEl,'timeupdate'), new Promise(r=>setTimeout(r,80)) ]);
          try { videoEl.pause(); } catch {}
          // zurück auf frame 0 „snappen“ (optisch identisch)
          try { videoEl.currentTime = 0; } catch{}
        }
      
        function swapTo(el){
          // el = der Layer, der sichtbar werden soll
          el.classList.add('active');
          active.classList.remove('active');
        
          const prev = active; // das war vorher sichtbar
          active = el;         // jetzt ist el sichtbar
          back   = prev;       // back ist nun der andere Layer (frei zum Vorladen)
        }

      
        async function prepareFreezeOf(idx){
          // PRE lädt den Forward-Clip des Zielsegments auf Frame 0
          setSrc(PRE, SEGMENTS[idx].fwd);
          // warten bis Daten da
          await Promise.race([ once(PRE,'loadeddata'), new Promise(r=>setTimeout(r,400)) ]);
          await primeAtStart(PRE); // Decoder warm
        }
      
        function showPreOnActive(){
          // PRE-Inhalt auf BACK kopieren (Quelle teilen) und sichtbar machen
          // Direkt PRE sichtbar machen wäre auch ok, aber wir halten PRE unsichtbar.
          setSrc(back, PRE.currentSrc || PRE.src);
          // Wir sind sicher: PRE ist bei 0; kopiere state
          try { back.currentTime = PRE.currentTime; } catch{}
          back.pause();
          swapTo(back);
        }
      
        // ====== Aktionen ==========================================================
        // Weiter: akt. Forward abspielen; währenddessen nächsten Forward auf PRE einfrieren.
        async function playForward(){
          if (busy || i >= SEGMENTS.length-1) return;
          busy = true; setButtons();
        
          const nextIdx = i + 1;
        
          // === letzter Index? ===
          if (nextIdx === SEGMENTS.length-1) {
            // wir sind beim letzten Segment: einfach bis zum Ende spielen und stehenbleiben
            try { await active.play(); } catch {}
            active.onended = () => {
              // am allerletzten Frame einfrieren
              try { active.pause(); } catch {}
              try { active.currentTime = active.duration; } catch {}
              i = nextIdx;
              setCopy(i);
              busy = false; setButtons();
            };
            return;
          }
        
          // --- normaler Übergang mit PRE ---
          setSrc(back, SEGMENTS[i].fwd);
          await Promise.race([ once(back,'loadeddata'), new Promise(r=>setTimeout(r,400)) ]);
          try { await back.play(); } catch {}
          swapTo(back);
        
          prepareFreezeOf(nextIdx).catch(()=>{});
        
          active.onended = async () => {
            try { active.pause(); } catch{}
            showPreOnActive();
            i = nextIdx;
            setCopy(i);
            busy = false; setButtons();
          };
        }

        
        async function playBackward(){
          if (busy || i === 0) return;
          busy = true; setButtons();
          // fadeOn();  <-- ENTFERNEN
        
          const prevIdx = i - 1;
          setSrc(back, SEGMENTS[prevIdx].rev);
          await Promise.race([ once(back,'loadeddata'), new Promise(r=>setTimeout(r,400)) ]);
          try { await back.play(); } catch {}
          swapTo(back);
        
          prepareFreezeOf(prevIdx).catch(()=>{});
        
          active.onended = async () => {
            try { active.pause(); } catch{}
            showPreOnActive();
            i = prevIdx;
            setCopy(i);
            // fadeOff(); <-- ENTFERNEN
            busy = false; setButtons();
          };
        }

        // ====== Init ==============================================================
        (async function init(){
          setCopy(0);
      
          // Startframe von Segment 0 auf active anzeigen (ohne Blinken)
          setSrc(active, SEGMENTS[0].fwd);
          await Promise.race([ once(active,'loadeddata'), new Promise(r=>setTimeout(r,400)) ]);
          await primeAtStart(active);
          active.classList.add('active');
          setButtons();
      
          // Preload direkt den Freeze für Segment 1 (falls vorhanden)
          if (SEGMENTS.length > 1) prepareFreezeOf(1).catch(()=>{});
      
          // Events
          btnNext.addEventListener('click', playForward);
          btnPrev.addEventListener('click', playBackward);
          window.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight' || e.key === 'Enter') { e.preventDefault(); playForward(); }
            if (e.key === 'ArrowLeft') { e.preventDefault(); playBackward(); }
          });
        })();
      })();
    </script>
  </body>
</html>
























































































































































